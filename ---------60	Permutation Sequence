//
//  60	Permutation Sequence.cpp
//  leetcode_medium
//

#include <stdio.h>
#include <vector>
#include <iostream>
using namespace std;

/*
The set [1,2,3,…,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):

"123"
"132"
"213"
"231"
"312"
"321"
Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.
 */

/*
 两个解法。
 第一，DFS - 递归遍历所有可能，然后累加计算，直至到K为止。
 
 第二，数学解法。
 
 假设有n个元素，第K个permutation是 a1, a2, a3, .....   ..., an
 那么a1是哪一个数字呢？
 
 那么这里，我们把a1去掉，那么剩下的permutation为a2, a3, .... .... an, 共计n-1个元素。 n-1个元素共有(n-1)!组排列，那么这里就可以知道
 
 设变量K1 = K
 a1 = K1 / (n-1)!
 
 同理，a2的值可以推导为
 a2 = K2 / (n-2)!
 K2 = K1 % (n-1)!
 .......
 a(n-1) = K(n-1) / 1!
 K(n-1) = K(n-2) /2!
 
 an = K(n-1)
 */

class Solution {
public:
    string getPermutation(int n, int k) {
        vector<int> nums(n);
        int permCount = 1;
        for (int i = 0; i < n; i++) {
            nums[i] = i + 1;
            permCount += (i + 1);
        }
        // change k from (1,n) to (0,n-1) to accord to index
        k--;
        string targetNum;
        for (int i = 0; i < n; i++) {
            permCount = permCount / (n - i);
            int choosed = k / permCount;
            targetNum.push_back(nums[choosed] + '0');
            //restruect nums since one num has been picked
            for (int j = choosed; j < n - i; j++) {
                nums[j] = nums[j + 1];
            }
            k = k % permCount;
        }
        return targetNum;
    }
};
//http://fisherlei.blogspot.sg/2013/04/leetcode-permutation-sequence-solution.html
//http://okckd.github.io/blog/2014/05/19/Permutation-Sequence/
